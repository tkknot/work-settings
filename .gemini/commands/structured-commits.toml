description = "作業内容を回想し構造化されたコミットを作成"

prompt = """

# Structured Commits

これまでの作業内容を回想し、コミットメッセージ群自体がPRを見た時の変更履歴となるようにコミットを作成します。

## 実行手順

### Phase 1: 作業の回想

1. **これまでのやり取りを回想**: 会話の中であなた（AI）が行った変更を思い出す
2. 変更した内容をリストアップ

### Phase 2: 差分の確認

1. `git diff` と `git status` を実行して、実際の変更内容を確認
2. **回想と実際の差分を照合**: 抜け漏れがないか確認
   - **あなたが行っていない変更が含まれている場合は「人間による変更」として認識**
3. **変更のグループ化**: 関連する変更をコミット単位でまとめる

### Phase 3: 作業手順の整理

1. **手順をリスト化**: Phase 1-2で整理した内容を、コミット予定の順番でリストとして出力
2. ユーザーに確認を促す（必要に応じて調整）

### Phase 4: コミットの作成

1. **グループ単位でコミット**: 関連する変更をまとめてコミット
2. **ステージング**: 関連するファイルのみを `git add` でステージング
3. **コミットメッセージ作成**: `.github/.COMMIT_TEMPLATE` に従って作成
   - **1行に収まるようにする**
   - Prefix: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`
   - 形式: `<Prefix>: 変更内容の要約を現在形で記載`
4. `git commit -m "<message>"` でコミット作成
5. すべてのグループについて、2-4を繰り返す

### Phase 5: 確認

1. `git log --oneline -n <コミット数>` で作成したコミットを確認
2. コミットメッセージ群を見て、作業の流れが理解できるか確認

## 重要な制約

- エラーが発生しているファイルはcommitしない
- リモートへのpushは**行わない**
- commitメッセージにAIの署名は**追加しない**
- **コミットメッセージ群がPRの手順書として読めることを意識する**
- コミットメッセージに（👤人間による変更）という文言は不要です
- ghコマンドが使用できない場合は、`gh`コマンドの有無の確認と`gh auth login`コマンドの実行を促す

## 出力例

---
コミット作成完了:

1. feat: 会員証発行APIのエンドポイントを追加
2. feat: 会員証発行のビジネスロジックを実装
3. test: 会員証発行APIのユニットテストを追加
4. docs: 会員証発行APIのREADMEを更新
---
"""
